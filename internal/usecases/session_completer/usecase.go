package session_completer

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"speech-processing-service/internal/drivers/storage"
	"speech-processing-service/internal/entity"
	"speech-processing-service/internal/errs"

	"go.uber.org/zap"
)

const (
	promptBasis = "You are an English language assessment assistant. A student has answered three open-ended questions in English. Your task is to analyze the language level and provide structured feedback based on the text.\n\nKeep in mind:\n- The text is generated by speech-to-text API, so ignore errors related to punctuation or spelling that might have come from automatic transcription.\n- Focus on evaluating the actual language proficiency and content of the answer.\n\nBe especially attentive to grammar mistakes:/n- Only include errors that break grammar rules (tense, articles, prepositions, subject-verb agreement, word order, etc.)./n- Do NOT include stylistic or semantic issues, such as vague phrases, awkward wording, or lack of specificity â€” even if the sentence could be improved stylistically, if it's grammatically correct, move the suggestion to the \"rephrase_suggestions\" section.\n- Explain the grammar rule that was broken in each case./nAdapt all the explanations to scored level of English\n\nProvide the results in the following structured JSON format:\n\n{\n  \"overall_level\": \"<CEFR Level: A1, A2, B1, B2, C1, or C2>\",\n  \"top_words\": [\n    {\n      \"words\": \"<word>\",\n      \"level\": \"<A1-C2>\"\n    }\n  ],\n  \"grammar_issues\": [\n    {\n      \"sentence\": \"<sentence with grammar mistake>\",\n      \"explanation\": \"<what is wrong and what rule was violated>\",\n \"corrected_sentence\": \"correct the mistake\"    }\n  ],\n  \"rephrase_suggestions\": [\n    {\n      \"original\": \"<original sentence or part>\",\n      \"suggestion\": \"<how it can be rephrased to sound better>\"\n    }\n  ],\n  \"overall_feedback\": \"<general impression, fluency, vocabulary range, and what the user can work on. Speak directly to the user>\"\n}\n\nNow, here is the user's response to three questions:\n\n"
)

type AnswersQuestionsGetter interface {
	GetAnswerBySessionID(ctx context.Context, sessionID string) ([]storage.Answer, error)
	GetQuestionByID(ctx context.Context, id int) (storage.Question, error)
}

type URLGetter interface {
	GenerateUrl(ctx context.Context, imagePath string, isAnswer bool) (string, error)
}

type AudioTranscriber interface {
	TranscribeAudio(ctx context.Context, url string) (string, error)
}

type TextAnalyzer interface {
	AnalyzeText(ctx context.Context, prompt string) (string, error)
}

type UseCase struct {
	logger *zap.Logger

	answersGetter    AnswersQuestionsGetter
	urlGetter        URLGetter
	audioTranscriber AudioTranscriber
	textAnalyzer     TextAnalyzer
}

func New(
	logger *zap.Logger,
	answersGetter AnswersQuestionsGetter,
	urlGetter URLGetter,
	audioTranscriber AudioTranscriber,
	textAnalyzer TextAnalyzer,
) UseCase {
	return UseCase{
		logger: logger,

		answersGetter:    answersGetter,
		urlGetter:        urlGetter,
		audioTranscriber: audioTranscriber,
		textAnalyzer:     textAnalyzer,
	}
}

func (u *UseCase) CompleteSession(ctx context.Context, sessionID string) (entity.AnalyzeTextResult, error) {
	prompt := promptBasis

	answersDB, err := u.answersGetter.GetAnswerBySessionID(ctx, sessionID)
	if err != nil {
		return entity.AnalyzeTextResult{}, err
	}

	if len(answersDB) == 0 {
		return entity.AnalyzeTextResult{}, errs.New(errs.ErrNotFound, "answers not found")
	}

	for _, answerDB := range answersDB {
		url, err := u.urlGetter.GenerateUrl(ctx, answerDB.Filename, true)
		if err != nil {
			u.logger.Error("u.urlGetter.GenerateURl", zap.Error(err))
			return entity.AnalyzeTextResult{}, err
		}

		question, err := u.answersGetter.GetQuestionByID(ctx, answerDB.QuestionID)
		if err != nil {
			u.logger.Error("u.answersGetter.GetQuestionByID", zap.Error(err))

			return entity.AnalyzeTextResult{}, err
		}

		transcription, err := u.audioTranscriber.TranscribeAudio(ctx, url)
		if err != nil {
			u.logger.Error("u.audioTranscriber.TranscribeAudio", zap.Error(err))

			return entity.AnalyzeTextResult{}, err
		}

		prompt += fmt.Sprintf("Question: %s\nAnswer: %s\n", question.Question, transcription)
	}

	resultStr, err := u.textAnalyzer.AnalyzeText(ctx, prompt)
	if err != nil {
		u.logger.Error("u.textAnalyzer.AnalyzeText", zap.Error(err))

		return entity.AnalyzeTextResult{}, err
	}

	startIndex := strings.Index(resultStr, "{")
	if startIndex != -1 {
		resultStr = resultStr[startIndex:]
	}

	endIndex := strings.LastIndex(resultStr, "}")
	if endIndex != -1 {
		resultStr = resultStr[:endIndex+1]
	}

	var result entity.AnalyzeTextResult
	err = json.Unmarshal([]byte(resultStr), &result)
	if err != nil {
		fmt.Println("Error unmarshaling JSON:", err)

		return entity.AnalyzeTextResult{}, errs.New(errs.ErrDecodingJSON, err.Error())
	}

	return result, nil
}
